#unum-unum.jl

#contains information about the unum type and helper functions directly related to constructor.

#the unum type is an abstract type.  We'll be overloading the call function later
#so we can do "pseudo-constructions" on this type.
doc"""
`Unum{ESS,FSS}` creates a Unum with esizesize ESS and fsizesize FSS.

NB:  Internally this may cast to a different Unum type (UnumLarge or UnumSmall)
for performance purposes.  The `Unum{ESS,FSS}(...)` constructor is always safe
and purposes where computational performance is an issue, use of the internal
types is recommended.
"""
abstract Unum{ESS, FSS} <: Utype
export Unum

#general parameter checking for unums.
function __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)
  (ESS > 6) && throw(ArgumentError("ESS == $ESS > 6 disallowed in current implementation"))
  (FSS > 11) && throw(ArgumentError("FSS == $FSS > 11 disallowed in current implementation"))
  _mfs = max_fsize(FSS)
  (fsize > _mfs) && throw(ArgumentError("fsize == $fsize > $_mfs maximum for FSS == $FSS."))
  _mes = max_esize(ESS)
  (esize > _mes) && throw(ArgumentError("esize == $esize > $_mes maximum for ESS == $ESS."))
  _mbe = max_biased_exponent(esize)
  (exponent > _mbe) && throw(ArgumentError("exponent == $exponent > $_mbe maximum for esize == $esize."))
  #check to see that the fraction contents match.
  (FSS < 7) && (!isa(fraction, UInt64)) && throw(ArgumentError("FSS == $FSS requires a Uint64 fraction"))
  (FSS > 6) && (!isa(fraction, ArrayNum{FSS})) && throw(ArgumentError("FSS == $FSS requires a ArrayNum{$FSS} fraction"))
  nothing
end

doc"""
`Unums.UnumSmall{ESS,FSS}` is the internal type for Unums with FSS < 7.  These
numbers require a single unsigned 64-bit integer to store their fractions.
"""
type UnumSmall{ESS, FSS} <: Unum{ESS, FSS}
  fsize::UInt16
  esize::UInt16
  flags::UInt16
  fraction::UInt64
  exponent::UInt64
  @dev_check ESS FSS function UnumSmall(fsize, esize, flags, fraction, exponent)
    new(fsize, esize, flags, fraction, exponent)
  end
end

#unsafe copy constructor
UnumSmall{ESS,FSS}(x::UnumSmall{ESS,FSS}) = UnumSmall{ESS,FSS}(x.fsize, x.esize, x.flags, x.fraction, x.exponent)
UnumSmall{ESS,FSS}(x::UnumSmall{ESS,FSS}, flags::UInt16) = UnumSmall{ESS,FSS}(x.fsize, x.esize, flags, x.fraction, x.exponent)

#parameter checking.  The call to this check is autogenerated by the @dev_check macro
function __check_UnumSmall(ESS, FSS, fsize, esize, flags, fraction, exponent)
  __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)
  (FSS > 6) && throw(ArgumentError("UnumSmall internal class is inappropriate for FSS == $FSS > 6."))
  nothing
end

doc"""
`Unums.UnumLarge{ESS,FSS}` is the internal type for Unums with FSS > 6.  These
numbers require an array of 64-bit integers to store their fractions.
"""
type UnumLarge{ESS, FSS} <: Unum{ESS, FSS}
  fsize::UInt16
  esize::UInt16
  flags::UInt16
  fraction::ArrayNum{FSS}
  exponent::UInt64
  @dev_check ESS FSS function UnumLarge(fsize, esize, flags, fraction, exponent)
    new(fsize, esize, flags, fraction, exponent)
  end
end

#unsafe copy constructors
UnumLarge{ESS,FSS}(x::UnumLarge{ESS,FSS}) = UnumLarge{ESS,FSS}(x.fsize, x.esize, x.flags, x.fraction, x.exponent)
UnumLarge{ESS,FSS}(x::UnumLarge{ESS,FSS}, flags::UInt16) = UnumLarge{ESS,FSS}(x.fsize, x.esize, flags, x.fraction, x.exponent)

#parameter checking.  The call to this check is autogenerated by the @dev_check macro
function __check_UnumLarge(ESS, FSS, fsize, esize, flags, fraction, exponent)
  __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)
  (FSS < 7) && throw(ArgumentError("UnumLarge internal class is inappropriate for FSS == $FSS < 7."))
  nothing
end

#override call for copy constructor
function Base.call{ESS, FSS}(::Type{Unum{ESS,FSS}}, x::Unum{ESS,FSS})
  __general_unum_check(ESS, FSS, x.fsize, x.esize, x.flags, x.fraction, x.exponent)
  (FSS < 7) ? UnumSmall(x) : UnumLarge(x)
end

#override call to allow direct instantiation using the Unum{ESS,FSS} pseudo-constructor.
#because this call function is intended to be used strictly for human-interaction purposes.
function Base.call{ESS, FSS}(::Type{Unum{ESS,FSS}}, fsize::UInt16, esize::UInt16, flags::UInt16, fraction::UInt64, exponent::UInt64)
  __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)

  #mask out values outside of the flag range.
  flags &= UNUM_FLAG_MASK
  #be ready to override the trimmed fsize in case we specify ubit on.
  fsize_override::UInt16 = (flags & UNUM_UBIT_MASK != 0) ? fsize : 0
  #trim fraction to the length of fsize.  Return the trimmed fsize value and
  #ubit, if appropriate.
  (fraction, fsize, ubit) = __frac_trim(fraction, fsize)
  #apply the ubit change.
  flags |= ubit
  #if we started as a ubit, override the shortened fsize.
  fsize = max(fsize, fsize_override)

  UnumSmall{ESS,FSS}(fsize, esize, flags, fraction, exponent)
end

const __SAFE_CONSTRUCTOR_REGISTER = 1

function Base.call{ESS,FSS}(::Type{Unum{ESS, FSS}}, fsize::UInt16, esize::UInt16, flags::UInt16, fraction::ArrayNum{FSS}, exponent::UInt64)
  __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)

  #mask out values outside of the flag range.
  flags &= UNUM_FLAG_MASK
  #be ready to override the trimmed fsize in case we specify ubit on.
  fsize_override::UInt16 = (flags & UNUM_UBIT_MASK != 0) ? fsize : 0
  #trim fraction to the length of fsize.  Return the trimmed fsize value and
  #ubit, if appropriate.
  (fsize, ubit) = __frac_trim!(fraction, fsize, Val{__SAFE_CONSTRUCTOR_REGISTER}())
  #apply the ubit change.
  flags |= ubit
  #if we started as a ubit, override the shortened fsize.
  fsize = max(fsize, fsize_override)

  UnumLarge{ESS,FSS}(fsize, esize, flags, fraction, exponent)
end

#for convenience we can also call a big unum with an
function Base.call{ESS,FSS}(::Type{Unum{ESS, FSS}}, fsize::UInt16, esize::UInt16, flags::UInt16, fraction::Array{UInt64, 1}, exponent::UInt64)
  #if we have a big fsize, recast fraction as an ArrayNum{FSS}
  fraction = ArrayNum{FSS}(fraction)
  __general_unum_check(ESS, FSS, fsize, esize, flags, fraction, exponent)

  #mask out values outside of the flag range.
  flags &= UNUM_FLAG_MASK
  #be ready to override the trimmed fsize in case we specify ubit on.
  fsize_override::UInt16 = (flags & UNUM_UBIT_MASK != 0) ? fsize : 0
  #trim fraction to the length of fsize.  Return the trimmed fsize value and
  #ubit, if appropriate.
  (fsize, ubit) = __frac_trim!(fraction, fsize, Val{__SAFE_CONSTRUCTOR_REGISTER}())
  #apply the ubit change.
  flags |= ubit
  #if we started as a ubit, override the shortened fsize.
  fsize = max(fsize, fsize_override)

  #pass this through an intermediate Int64Array number constructor.
  UnumLarge{ESS,FSS}(fsize, esize, flags, ArrayNum{FSS}(fraction), exponent)
end

doc"""
`unum(Unum{ESS,FSS}, flags, fraction, exponent)` is a safe constructor that has
slightly more human-comprehensible parameters.  The first argument to this
pseudo-constructor must be a Unum type value that relays the environment
signature to the unum call so that the appropriate unum can be made.
"""
function unum{ESS,FSS}(::Type{Unum{ESS,FSS}}, flags::UInt16, fraction, exponent::Int64)
  exponent < min_exponent(ESS) && throw(ArgumentError("exponent $exponent out-of-bounds for ESS $ESS"))
  exponent > max_exponent(ESS) && throw(ArgumentError("exponent $exponent out-of-bounds for ESS $ESS"))

  #decode the exponent
  (esize, exponent) = encode_exp(exponent)
  #let's be lazy about the fsize.  The safe unum pseudoconstructor will
  #handle trimming that down.
  fsize = max_fsize(FSS)

  Unum{ESS,FSS}(fsize, esize, flags, fraction, exponent)
end
export unum

#masks for the unum flags variable.
const UNUM_SIGN_MASK = UInt16(0x0002)
const UNUM_UBIT_MASK = UInt16(0x0001)
const UNUM_FLAG_MASK = UInt16(0x0003)
#nb: in the future we may implement g-layer shortcuts, which allow short-circuiting
#of type checks.
const UNUM_NAN__MASK = UInt16(0x8000)
const UNUM_ZERO_MASK = UInt16(0x4000)
const UNUM_INF__MASK = UInt16(0x2000)
const UNUM_NINF_MASK = UInt16(0x1000)
const UNUM_SSS__MASK = UInt16(0x0800)
const UNUM_SHORTCUTS = UInt16(0xF800)
